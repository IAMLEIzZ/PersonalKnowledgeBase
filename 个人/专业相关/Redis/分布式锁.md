	讲述分布式锁的几类实现方式 & Redis 怎么实现分布式锁
## 分布式锁的实现方式：
分布式锁在实现上主要分类以下两类：
1. 基于主动轮询的锁竞争
2. 基于事件回调的锁竞争

| 实现方式   | 代表产品           | 优点                                     | 缺点                                  | 适用场景     |
| ------ | -------------- | -------------------------------------- | ----------------------------------- | -------- |
| 主动轮询   | Redis/Mysql    | 能及时获得锁资源，无需阻塞进程，不用进行进程上下文切换，相对来说操作程度较轻 | 如果持续无法获得锁资源，会导致 CPU 长时间空转，浪费 CPU 资源 | 并发度较轻的场景 |
| 监听事件回调 | Etcd/Zookeeper | 获取不到锁的进程被阻塞，是事件响应驱动的，能有效利用 CPU 资源      | 需要阻塞进程，进程上下文切换成本较高；                 | 并发度较高的场景 |
___
## 两种实现方式：
分布式锁实现主要要解决的几个难点
	1. A 锁到期了，怎么续约，怎么不让其他节点非法获得锁
	2. A 获得锁后宕机了，该怎么正常解锁，从而使得不让其他进程傻等
	3. 加锁方和解锁方正常情况下应该是同一人
	4. 集群节点故障会不会导致一锁多持
### 主动轮询方式：
基于 Redis 和 Mysql 实现的分布式锁，是典型的基于主动轮询方式的分布式锁。他们的核心步骤可以分为以下几步：
1. 上锁：在数据库中为对应的字段设置一个唯一的锁标识，通过在数据库中写上对应的上锁标识和上锁时间，即代表上锁
2. 解锁：当上锁进程解锁的时候，先去 check 这个锁是不是他所获得的，如果是，才有资格解锁
3. 获得锁：进程在上锁之前要先去数据库中检查对应字段的锁是否存在，如果存在，则自旋 + CAS 进行轮询监听，如果不存在则上锁。
---
基于上述方式实现的分布式锁，还需要考虑两个问题哦。
case1：假设 A 上了锁，活已经干完了，但是自己宕机了，没有及时解锁，导致后续进程等待时间过长，怎么办？（**这个还算轻的**）
case2：假设 A 上了锁，但是活还干完，锁到期自动取消了，结果别的进程此时获得了锁，开始继续操作同一个数据，怎么办？（**相当严重的数据不一致性错误**）
case3：基于 Redis 的分布式锁，我们知道 Redis 集群是 AP 优先的，异步同步，可能在某个时间点会出现不一致性，假设 A 在主节点上上锁并且完成了修改，但是此时主节点宕机了，锁还没有同步给其他节点，其他节点发现 master 宕机，重新选举出了 Leader，新 Leader 此时没有锁，这时 B 进程来顺利获得锁。（**一锁多持错误**）
Redis 中用 **watch dog** 来进行续约操作，为 case2 兜底；用 **RedLock** 为 case3 兜底。
### 事件回调方式：
Etcd 和 Zookeeper 是经典的基于事件回调方式的分布式控件，他们的核心步骤分为以下几步：
1. 上锁：当获得锁后，同时获得得还有一份 Lease，然后会异步启动一个进程，在后台持续 Watch 这个 Lease 的到期时间。
2. 解锁：如果任务结束，则由主进程亲自解锁并且销毁 Lease；如果后台监听 Lease，Lease 到期但未续约成功，则解锁并销毁 Lease。（**防止上面的 case2**）
3. 获得锁：假设一个进程此时尝试获得锁失败，他并不会轮询，而是创建一个监听时间，用来监听锁被释放这个时间，当对应锁被释放后，监听事件回调唤醒对应的阻塞进程，从而达到基于事件回调方式的分布式锁。
---
基于上述方式锁实现的分布式锁，也有一些小问题。
1. 假设此时一万个进程同时监听一个锁，如果锁被释放了，一万个进程同时去加锁，会造成严重的性能抖动。这就是**惊群效应**
### 两种方式的对比：
1. 死锁问题：对于二者的死锁，第一种方式是通过设定锁过期时间 + Watch dog 续约来解决的，第二种方式是通过异步启动进程来续约的。二者都是一个定时 + 续约来兜底死锁
2. 性能问题：Redis 是弱一致性的，所以相较于 Etcd 有较高的性能（因为 Etcd 基于 Raft，强一致性需要大多数节点接受提议才能上锁）
3. 锁的超时释放：Etcd 通过 Lease 到期释放，而 Redis 需要通过 Lua 脚本来实现原子性
	对于上述第三点，这里放个栗子
	1. **进程 A 获取了锁**，值为 "A_UUID"。
	2. **进程 A 执行 GET("my_lock")**，获取 "A_UUID"。
	3. **锁超时失效**（或被 Redis 淘汰），锁**自动释放**。
	4. **进程 B 获取了新的锁**，值变成 "B_UUID"。
	5. **进程 A 继续执行 DEL("my_lock")**，但 **它本来要删除 "A_UUID"，却误删了 "B_UUID"** 的锁！
	6. **进程 B 以为自己仍然持有锁，但实际上锁已经被 A 删除了，发生数据竞争！**

## 基于 Redis 的分布式锁的实现：
	分布式锁要实现的几个关键点：
	1. 独占性：一个锁只能被一方拥有
	2. 强健性：不能产生死锁，就是当上锁方宕机无法解锁，此时锁要有自己的鲁棒性，要能自己感知到这一点，然后解锁
	3. 对称性：加锁方和解锁方应该一致
	4. 高可用：对于分布式锁，要保证一致性的可用锁
综上，在上述四点的描述下，用 Redis 上锁只使用 Set Key Val + NX + Expire 是不够的。
比如说需要考虑：
1. 一把锁应该有且被标识一个使用者标识，所以 Val 应该能唯一标识一个使用者。（独占性和对称性）
2. Expire 看起来能帮助控制持有时间，但是上锁方怎么知道应该设置多久呢？只能靠经验来设置，因此需要有保障机制来帮助续约。以防出现操作没结束，锁先结束了。（强健性）
3. 高可用性，Redis 集群是牺牲了 C 的弱一致性分布式集群，那就会出现一个问题。当 A 在 Leader 上立刻上锁开始操作，但此时锁数据未同步到其他节点，这是其他Leader 宕机，其他节点上任，那么就会导致一锁多用。（高可用）
### Watch Dog & RedLock：
简而言之，WatchDog 是获得锁后，启动的异步进程续约机制；RedLock 是基于 Majority 的获得锁机制，要保证锁在大多数节点上都可用才行。基于上面这两个控件，加上Key 唯一标识一把锁，Val 唯一标识一个锁用户，从而实现一个完整的分布式锁。