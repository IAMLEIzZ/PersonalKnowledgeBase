### Redis 持久化
首先要知道 Redis 持久化的使用场景，Redis 持久化是因为是一种 memstore，断电会丢失，所以归根结底 Redis 持久化是为了数据恢复，这也就引出了两个适用场景
1. 单个 Redis 节点断电保护需要持久化来保障（数据恢复）
2. Redis 集群中，一个新节点加入集群的时候，需要通过主节点的持久化数据来进行同步
Redis 持久化主要有两种方式：**AOF 日志** 和 **RDB 快照**
#### AOF （Append Only File）日志
AOF 日志记录并不是数据库中的 KV 值，而是这些值的操作，例如 Name:xiaolei，那么在 AOF 日志中这个值对应的是 Set Name xiaolei。
##### AOF 写入步骤
AOF 的记录过程是 Redis 客户端先写入缓存，然后将操作记录到 AOF 日志中（如果优先记录操作万一操作是错误的呢？）
![[Pasted image 20250309155727.png]]
可以看出AOF 条目先被加入到了 buffer 中，因此引出三种写入磁盘的策略
![[Pasted image 20250309155820.png]]
##### AOF 日志过大
当 AOF 日志超过所设置的阈值，会进行压缩。这里的压缩实际上指的是重写，读取当前数据库中的所有键值对（只要最新的数据哦），然后将每个键值对用一条命令写到新的 AOF 中，最后替换掉旧的 AOF。
![[Pasted image 20250309160219.png]]
##### AOF 重写过程
![[Pasted image 20250309160430.png]]
#### RDB（Redis DataBase）快照
这个快照实际上就是数据库内容的副本，既然有了 AOF 为什么还需要 RDB 呢？因为 AOF 是操作，而 RDB 是实际的数据，Redis 从 AOF 中恢复数据需要一条一条执行操作而从 RDB 中恢复直接赋值即可，效率很高。
（Redis 中的快照是全量快照，很重，频繁执行快照会影响性能，而执行频率太低吧，宕机后，又会丢失数据）
##### RDB 快照过程
（RDB 快照不会阻塞主进程，而是由主进程 fork 一个自进程去完成快照生成）
因此这里引出了下一个问题，**RDB 过程中能不能进行数据修改？**
既然主进程是不阻塞的，自然是可以进行修改的，但是！这个修改不会被同步到正在进行的 RDB 中，采用了**写时复制技术**，如果此时修改了一个数据，这个数据会先复制出一个副本，这个副本会被写入到快照中（旧数据），新的会在原本基础上修改。（快照实际上是对数据库某个时间点数据的一种记录策略，因此看上去好像新数据没有写入这个快照中这不是没持久化吗？但实际上持久化的是某个时间节点前的数据）。
![[Pasted image 20250309162141.png]]
#### 混合持久化策略
结合二者优点
1. **开启 AOF 重写时**
• Redis **会先将当前数据集转换为 RDB 格式**，并写入新的 AOF 文件的头部部分。
2. **重写过程中，新的写入请求仍然发生**
• 在 AOF 重写的同时，Redis 仍然处理客户端请求（写入命令）。
• 这些新请求的数据 **不能直接写入新的 AOF 文件**，否则会丢失部分数据。
• **这些新请求的数据会被暂存到 AOF 缓冲区**。
3. **重写完成后**
• Redis **将 AOF 缓冲区中的增量 AOF 记录追加到新的 AOF 文件中**。
• 这样，新的 AOF 文件就由 **RDB 快照数据 + 追加的 AOF 日志** 组成。
### Redis高可用
![[Pasted image 20250309162642.png]]
### Redis 过期删除和内存淘汰
适用惰性（不主动删除键）删除和定期（定期扫描过期键主动删除）删除
#### RDB 和 AOF 的过期键处理
| **持久化方式** | **过期 key 是否会被保存**          | **何时删除过期 key**      |
| --------- | -------------------------- | ------------------- |
| **RDB**   | 可能会被保存到 RDB 文件             | Redis **重启时** 检查并删除 |
| **AOF**   | AOF 直接记录 EXPIRE，**重写时会移除** | **AOF 重写时** 自动删除    |
（RDB 从服务器一般不检查删除）
### Redis 缓存设计
CTM 的缓存雪崩、缓存击穿、缓存穿透。说白了就是 Redis 没帮 Mysql 挡住大量的请求。
#### 缓存雪崩
大量定时 Key 在同一时间到期，导致一大批 Key 失效，此时客户端又有大量的请求这些 Key，直接请求就去找 Mysql 了，然后给 Mysql 宕了。
##### 解决方案：
1. 随机 Key 的过期时间
2. 设计 Key 不过期（感觉呆呆的）
#### 缓存击穿
假设某个 Key 很热门，每秒有 1e5 次请求这个 Key，突然这个 Key 过期了，这 1e5 次的请求直接攻击 Mysql，又给 Mysql 宕了。（雪崩子集）
##### 解决方案：
1. 热点 Key 定期去延长他的存活时间
2. 不给热点 Key 设置过期时间
3. 互斥锁方案（有些影响性能）
#### 缓存穿透
一般是有人要搞你，故意用一个 Redis 中不会存在的 Key 去访问（例如年龄来个-98 岁），此时如果你的前后端没有对数据进行校验就直接查，会导致直接请求Mysql，如果存在大量这样的请求，你 Mysql 就又宕机啦。
##### 解决方案：
1. 收到请求后先校验，避免这种完全不可能的值
2. 布隆过滤器（多个哈希函数和位数组来判断某个关键字是否存在）
3. 设置未空值或者默认值，比如说把这些不合常理的值在 Redis 中设置为空，这样这些恶意请求就会被拦截在 Redis 处
### Redis 实战
#### Redis 如何实现延迟队列？
#### 大 Key
#### Redis 管道
#### 如何用 Redis 实现分布式锁

