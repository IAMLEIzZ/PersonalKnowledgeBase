GMP 中的G 指的是 go-routine，M 指的是一个内核态的线程，P 指的是调度器。假设现在 P 正在运行的 G 创建了一个新的 G，这个新的 G 会被放入本地的 G 队列（256），如果本地队列满了，他会把本地队列的 1/2 的 G 都转移到全局 G 队列中，然后将 new G 放入本地队列。如果 P 里面没有G，为了提高资源的利用率，他会先去全局的 G 队列中获取。如果全局 G 队列中没有，则会采用一个 Working Stealing 机制，去别的 P 的队列中偷取（最多偷四次？）。然后是 hand off 机制，如果 P 正在运行的某个 G 陷入了阻塞态，那么这个 M 和 P 会进行一个解绑，让 G 单独的跑在这个 M 上，然后 P 去找寻新的 M。P 的作用主要是解耦和，假设没有 P，如果 G 阻塞了，那么队列里其他的 G 都要跟着阻塞。在一个有本地队列可以减少加锁的次数。