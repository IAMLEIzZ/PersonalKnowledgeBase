| **Go 版本**    | **GC 机制**        | **特点**                   | **问题**          |
| ------------ | ---------------- | ------------------------ | --------------- |
| Go 1.5 - 1.7 | 三色标记 + Yuasa 写屏障 | 并发 GC，减少 STW 时间          | 需要额外的栈扫描        |
| **Go 1.8**   | **三色标记 + 混合写屏障** | **避免栈扫描，降低 GC 停顿时间**     | **更高效，基本无额外开销** |
| Go 1.9+      | **GC Pacer**     | **智能调整 GC 频率，减少 CPU 负担** | **大规模优化**       |
## V1.3 之前的版本（mark and sweep）
#### 垃圾回收方法
在 STW 阶段，直接检查程序的不可达对象，将不可达对象标记为垃圾，进行回收
#### mark and sweep 的缺点
- STW 会让程序暂停，影响程序执行的效率
- mark 需要扫描所有的对象（扫描整个heap）
- sweep 后会在 heap 上留下很多无法利用的内存碎片
#### V1.3 STW的执行流程与优化
![[Pasted image 20250308111804.png]]
![[Pasted image 20250308111846.png]]
即使在将 sweep 与后续程序并发执行，但是 STW 还是会暂停主程序的运行
## V1.5 引入三色标记法
#### 三色标记法
从程序的入口开始标记对象节点，其实就是图的层序遍历。
一开始所有的节点被标记为白色，然后将第一层可达节点标记为灰色，接着遍历灰色，将灰色的可达白色节点标记为灰色，然后将第一层标记的灰色节点标记未黑色。循环遍历，直到只剩白色和黑色节点对象，然后清除所有的白色对象（垃圾回收）
#### 只使用三色标记法存在的问题
因为三色标记法是不希望存在 STW 的（或者说尽可能减少 STW 的干预时间），但是不启动 STW 会出现以下情况：
1. 一个灰色节点 A 引用了一个白色节点 B
2. 此时一个黑色节点 C 引用了这个白色节点 B
3. 此时灰色节点 A 因为一些原因取消了对 B 的引用
此时，由于三色标记法的扫描只扫描灰色节点的后继节点，而不扫描黑色节点的后继，这会导致白色节点 B 无法被染色为灰色从而在后续的被 GC 掉，而此时 B 正在被 C 引用，进而引发程序出错。
#### 上述情况的触发条件
1. 黑色节点引用一个白色节点（**白色挂在黑色下**）
2. 白色节点的前驱节点或整个引用链路的首灰色节点取消对白色节点或白色节点的祖先节点的引用（**灰色断掉与该白色的通路**）
#### 两种解决三色标记法缺点的办法
从上述触发条件不难看出，只要破坏其中一个条件，即可。即满足下面两个要求即可
##### ”强-弱“ 三色不变式
- **强三色不变式**
	强制性不允许黑色节点引用白色节点
	![[Pasted image 20250308140948.png]]
- **弱三色不变式**
	允许黑色节点引用白色节点，但是在引用后，要讲白色节点染色为灰色
	![[Pasted image 20250308140955.png]]
为了满足上述的不变式，引入了两种屏障来保障 GC 的正确运作
#### 插入屏障（所有屏障制作用于堆段）
插入屏障要求黑色节点在引用白色节点的时候，将白色节点染色成为灰色，这样一就满足了强三色不变式，因为白色节点被染色成为了灰色节点
![[Pasted image 20250308141043.png]]
![[Pasted image 20250308141047.png]]
![[Pasted image 20250308141052.png]]
![[Pasted image 20250308141058.png]]
![[Pasted image 20250308141114.png]]
![[Pasted image 20250308141123.png]]
![[Pasted image 20250308141159.png]]
![[Pasted image 20250308141206.png]]
![[Pasted image 20250308141211.png]]
![[Pasted image 20250308141216.png]]
```
添加下游对象(当前下游对象slot, 新下游对象ptr) {   
  //1
  标记灰色(新下游对象ptr)   
  
  //2
  当前下游对象slot = 新下游对象ptr  				  
}

A.添加下游对象(nil, B)   //A 之前没有下游， 新添加一个下游对象B， B被标记为灰色
A.添加下游对象(C, B)     //A 将下游对象C 更换为B，  B被标记为灰色
```
上面的插入屏障虽然解决了原本的三色标记法存在问题，但是缺点是在最后阶段仍然需要启动 STW 进行 GC 回收
#### 删除屏障
删除屏障要求被删除引用的节点如果其自身是白色，则将其自己染色成为灰色，这样就满足了弱三色不变性，因为保证了被删除引用的白色节点其自身以及其后续引用关系不会断
![[Pasted image 20250308141241.png]]
![[Pasted image 20250308141244.png]]
![[Pasted image 20250308141247.png]]
![[Pasted image 20250308141251.png]]
![[Pasted image 20250308141254.png]]
![[Pasted image 20250308141257.png]]
![[Pasted image 20250308141301.png]]
```
添加下游对象(当前下游对象slot， 新下游对象ptr) {
  //1
  if (当前下游对象slot是灰色 || 当前下游对象slot是白色) {
  		标记灰色(当前下游对象slot)     //slot为被删除对象， 标记为灰色
  }
  
  //2
  当前下游对象slot = 新下游对象ptr
}

A.添加下游对象(B, nil)   //A对象，删除B对象的引用。  B被A删除，被标记为灰(如果B之前为白)
A.添加下游对象(B, C)		 //A对象，更换下游B变成C。   B被A删除，被标记为灰(如果B之前为白)
```
这种方式的回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉。

## V1.8 三色标记法 + 混合写屏障
V1.8 后Golang是用三色标记法加混合写屏障的方式来进行 GC（**屏障只作用于堆段**）
标记步骤：
- GC 开始后，所有程序可达的栈段对象都被直接标记为黑色
- 后续创建在栈段的对象都直接标记未黑色
- 在堆段中，被删除引用的节点（A->B 中的 B）被染色为灰色（屏障）
- 在堆段中，被添加的节点（A->B -----> A->C 中的 C）被染色为灰色（屏障）
![[Pasted image 20250308145209.png]]
![[Pasted image 20250308145213.png]]
#### Golang 中的混合写屏障满足弱三色不变式，只需要在程序开始时，并发的 scan 各 go-routine 的栈空间，使其直达节点变黑并一直保持，这个过程不需要STW，而标记结束后，因为栈在扫描后始终是黑色的，也无需再进行re-scan操作了，减少了STW的时间。


GC 准备阶段，小规模 STW，在 STW 期间，将栈上的对象全部置为黑色（一个栈一个栈进行，不是一次性将所有栈标记了），退出 STW。接下里 GC 协程与用户协程并发，当此时栈上 New 对象，则直接置为黑色，堆上对象按照混合写屏障来进行操作，(记住哦，栈上是无屏障的，也就是说栈上的对象引用堆上的对象是不触发屏障的) 

### 三个触发 GC 的时机
1. 守护协程定时查询
2. 用户 runtime.gc
3. 分配对象时检查堆内存是不是已经到达阈值，达到或者分配大对象的时候清除